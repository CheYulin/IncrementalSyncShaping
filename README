# 1. 赛题描述
题目主要解决的是数据同步领域范畴：实时增量同步，主要的技术挑战为模拟数据库的主备复制，提供"高效"的实时同步能力。即给定一批固定的增量数据变更信息，程序需要收集增量变更信息，并进行一定的数据重放计算，然后将最终结果输出到给定的目标文件中。增量数据的变更信息为了简化处理，会给出明文的数据，主要包含数据库的insert/update/delete三种类型的数据。具体的增量数据变更信息的数据格式见环境描述部分。数据重放主要是指模拟数据库的insert/update/delete语义，允许使用一些中间过程的存储。

# 2. 环境描述：

## 2.1 整体格式
有2台机器，简称A、B机器，A机器里会保存增量数据文件并且在固定的目录下提供10个文本文件，每个文本文件大概为1GB左右。每个文件有若干条变更信息。每条变更信息的记录由多列构成。文本中每行记录的格式为:


|     binaryId   | timestamp   |schema|table|变更类型|列信息|变更前列值| 变更后列值|列信息|列值|...|
| ------------- |-------------| -------------| -------------| -------------| ------------| -------------| -------------|------------| -------------|-------------| 



## 2.2 格式解释：

a. binaryId： 一个唯一的字符串编号,例子:000001:106

b. timestamp
  * 数据变更发生的时间戳,毫秒精度,例子:1489133349000
  
c. schema/table
  * 数据变更对应的库名和表名
  
d. 变更类型(主要分为I/U/D)
  * I代表insert, U代表update, D代表delete
  
d. 列信息
  * 列信息主要格式为，列名:类型:是否主键
  * 类型主要分为1和2
  * 1代表为数字类型，数字类型范围为0<= x <= 2^64-1
  * 2代表为字符串类型，0<= len <= 65536
  * 是否主键:0或者1 (0代表否，1代表是) 
  * 例1： id:1:1 代表列名为id,类型为数字,是主键
  * 例2： name:2:0 代表列名为name,类型为字符串,非主键
  

e. 列值
 * 主要分为变更前和变更后,<NULL>代表物理值为NULL(空值),(可不考虑字符串本身为"<NULL>"的特殊情况)
 * insert变更,只有变更后列值,其变更前列值为<NULL>,会包含所有的列信息
 * upadate变更,都会有变更前和后的列值,会包含主键和发生变更列的信息(未发生变更过的列不会给出,不是全列信息)
 * delete变革,只有变更前列值,会包含所有的列信息

## 2.3 格式例子
 



实际例子:
 * 000001:106|1489133349000|test|user|I|id:1:1|<NULL>|102|name:1:0|<NULL>|ljh|score:1:0|<NULL>|98|
 * 000001:106|1489133349000|test|user|U|id:1:1|102|102|score:1:0|98|95|  //执行了变更update score=95 where id=102


## 2.4 注意事项

1. 每一行代表一条变更数据,注意几个数据变更场景
2. 表的主键值也可能会发生update变更表的一行记录也可能发生先delete后insert
3. 整个数据变更内容是从零条记录开始构建的，即为任意一条行记录的update之前一定会有对应行的insert语句，delete之前也一定有一条insert,不考虑DDL变更产生列类型变化，也不需要考虑其他异常情况


#3. 程序要求
## 3.1 程序实现

分为server和client两部分：
     server会传入对应的文本的绝对路径地址，启动后需要开启网络服务，等待client建立链接之后，需要使用push机制主动开始推送数据到client
     client在启动时会传入server机器地址，主动和server建立链接之后，等待server推送数据，接收到数据后进行数据重放处理，等收完所有数据后，生成最终的结果到给定的目标文件名.
       语言仅限使用Java，整个运行环境为相同的24核物理机，内存为98GB，磁盘使用不做限制，选手可以使用的JVM堆大小为2.5G
## 3.2 程序校验
结果校验，会传入一批数据(格式为:schema+table+pk)，程序要按顺序返回每个主键对应记录的所有列的最终值.时间计算，会计算从程序启动到最后返回结果的时间差值

## 3.3 语言约定
使用JAVA

#4. 排名规则

在结果校验100%正确的前提下，按照总耗时进行排名，耗时越少排名越靠前，时间精确到毫秒。

